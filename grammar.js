/**
 * @file A general systems programming language
 * @author 17robots <mdray@duck.com>
 * @license MIT
 */

/// <reference types="tree-sitter-cli/dsl" />
// @ts-check

module.exports = grammar({
  name: "dyn",
  extras: $ => [
    /\s/,
  ],
  conflicts: $ => [
    [$.expr, $.type_expr],
    [$.expr, $.member_chain]
  ],
  rules: {
    source_file: $ => seq($.module_decl, repeat(choice($.decl, $.pub_decl))),
    module_decl: $ => seq('module', $.string, ';'),
    pub_decl: $ => seq('pub', $.decl),
    decl: $ => choice($.use_decl, $.fn_decl, $.var_decl, $.enum_decl, $.error_decl, $.struct_decl),
    use_decl: $ => seq('use', optional($.identifier), $.string, ';'),
    fn_decl: $ => seq($.identifier, '=', '(', optional($.param_list), ')', choice($.block, $.arrow_expr)),
    param_list: $ => seq($.param, repeat(seq(',', $.param))),
    param: $ => seq(optional('mut'), $.identifier, repeat(seq(',', $.identifier)), ':', $.type_expr, optional(seq('=', $.expr))),
    var_decl: $ => seq($.identifier, repeat(seq(',', $.identifier)), choice(seq(':', $.type_expr, '=', choice($.expr, $.type_expr)), seq(':=', choice($.expr, $.type_expr))), ';'),
    mut_var_decl: $ => seq( 'mut', $.identifier, repeat(seq(',', $.identifier)), optional(choice(seq(':', $.type_expr, '=', $.expr), seq(':=', $.expr))), ';' ),
    enum_decl: $ => seq($.identifier, '=', $.enum_literal),
    enum_param_list: $ => seq($.enum_member, repeat(seq(',', $.enum_member))),
    enum_member: $ => choice($.enum_param, $.fn_decl, $.var_decl, $.enum_decl, $.error_decl, $.struct_decl),
    enum_param: $ => seq($.identifier, optional(seq(':', $.type_expr)), ','),
    error_decl: $ => seq($.identifier, '=', $.error_literal),
    error_param_list: $ => seq($.error_member, repeat(seq(',', $.error_member))),
    error_member: $ => choice($.error_param, $.fn_decl, $.var_decl, $.error_decl, $.error_decl, $.struct_decl),
    error_param: $ => seq($.identifier, optional(seq(':', $.type_expr)), ','),
    struct_decl: $ => seq($.identifier, '=', $.struct_literal),
    struct_param_list: $ => seq($.struct_member, repeat(seq(',', $.struct_member))),
    struct_member: $ => choice($.struct_param, $.fn_decl, $.var_decl, $.struct_decl, $.struct_decl, $.struct_decl),
    struct_param: $ => seq($.identifier, repeat(seq(',', $.identifier)), ':', $.type_expr, ','),
    block: $ => seq('{', repeat($.stmt), '}'),
    label: $ => seq($.identifier, ':', $.block),
    arrow_expr: $ => seq('=>', $.expr, ';'),
    capture: $ => seq('|', optional('mut'), $.identifier, repeat(seq(',', optional('mut'), $.identifier)), '|'),
    stmt: $ => choice($.mut_var_decl, $.if_stmt, $.match_stmt, $.return_stmt, $.break_stmt, $.for_stmt, $.while_stmt, $.assign_stmt, $.decl, $.call, $.defer_stmt),
    call: $ => seq(choice($.member_chain, $.lambda_expr), $.fn_call_suffix, ';'),
    if_stmt: $ => seq('if', choice($.binary_expr, seq($.identifier, ':', $.capture)), choice($.block, $.stmt), optional(seq('else', choice($.block, $.stmt)))),
    if_expr: $ => prec.right(2,seq('if', choice($.binary_expr, seq($.identifier, ':', $.capture)), choice($.label, $.expr), 'else', choice($.label, $.expr))),
    match_stmt: $ => seq('match', $.expr, '{', optional($.match_arms), '}'),
    match_arms: $ => seq($.match_arm, repeat(seq(',', $.match_arm))),
    match_arm: $ => seq($.match_pattern, ':', optional($.capture), choice($.block, $.stmt)),
    match_expr: $ => seq('match', $.expr, '{', optional($.match_arms_expr), '}'),
    match_arms_expr: $ => seq($.match_arm, repeat(seq(',', $.match_arm_expr))),
    match_arm_expr: $ => seq($.match_pattern, ':', optional($.capture), choice($.block, $.expr)),
    match_pattern: $ => choice('_', $.expr, $.range_expr),
    defer_stmt: $ => seq('defer', optional($.capture), choice($.stmt, $.block)),
    return_stmt: $ => seq('return', optional($.expr), ';'),
    break_stmt: $ => seq('break', optional($.label_break), ';'),
    label_break: $ => seq(':', $.identifier, optional($.expr)),
    for_stmt: $ => seq('for', $.expr, ':', $.capture, choice($.label, $.stmt)),
    while_stmt: $ => seq('while', $.expr, optional(seq(':', $.capture)), choice($.label, $.stmt)),
    assign_stmt: $ => seq($.member_chain_lhs, $.assign_op, $.expr, ';'),
    assign_op: $ => choice("=", "+=", "-=", "*=", "/=", "%=", "^="),
    expr: $ => choice(
      $.literal,
      $.binary_expr,
      $.unary_expr,
      $.lambda_expr,
      seq($.lambda_expr, $.fn_call_suffix),
      $.identifier,
      $.grouped_expr,
      $.member_chain,
      $.struct_literal,
      $.enum_literal,
      $.error_literal,
      $.struct_initializer,
      $.enum_error_initializer,
      $.array_initializer,
      $.if_expr,
      $.match_expr,
    ),
    binary_expr: $ => prec.left(2, choice(seq($.expr, $.op, $.expr), seq($.type_expr, choice('==', '!='), $.type_expr))),
    op: $ => choice("+", "-", "*", "/", "%", "|", "&", "^", ">>", "<<", "==", "!=", "||", "&&"),
    unary_expr: $ => choice($.prefix_expr, $.postfix_expr),
    prefix_expr: $ => prec.right(3, seq(choice("-", "&", "!", "~"), $.expr)),
    postfix_expr: $ => seq($.expr, choice('++', '--')),
    member_chain: $ => seq($.identifier, $.suffix),
    suffix: $ => choice($.suffix_no_call, $.fn_call_suffix),
    suffix_no_call: $ => choice($.member_access_suffix, $.pointer_deref_suffix, $.optional_deref_suffix, $.array_index_suffix),
    member_chain_lhs: $ => seq($.identifier, repeat(choice($.suffix_no_call, seq($.fn_call_suffix, $.suffix_no_call)))),
    member_access_suffix: $ => seq('.', $.identifier),
    pointer_deref_suffix: $ => '.*',
    optional_deref_suffix: $ => '.?',
    array_index_suffix: $ => seq('[', $.expr, ']'),
    fn_call_suffix: $ => seq('(', optional($.argument_list), ')'),
    argument_list: $ => seq(choice($.expr, $.type_expr), repeat(seq(',', choice($.expr, $.type_expr)))),
    lambda_expr: $ => seq('(', optional($.param_list), ')', choice($.block, $.arrow_expr)),
    grouped_expr: $ => seq('(', $.expr, ')'),
    range_expr: $ => seq($.expr, '..', $.expr),
    literal: $ => choice($.number, $.string, $.char, $.boolean, 'undefined', 'null'),
    number: $ => choice($.int, $.float),
    int: $ => token(/[0-9]+/),
    float: $ => seq(optional($.int), '.', $.int),
    string: $ => seq('"', repeat($.string_character), '"'),
    string_character: $ => choice($.escape_sequence, $.non_escape_character),
    escape_sequence: $ => seq('\\', choice('\\', '"', 'n', 't', 'r')),
    non_escape_character: $ => /[^"]+/,
    char: $ => seq('\'', choice($.escape_sequence, $.non_escape_char), '\''),
    non_escape_char: $ => /[^']+/,
    boolean: $ => choice('true', 'false'),
    struct_literal: $ => seq('struct', '{', repeat($.struct_param_list), '}'),
    enum_literal: $ => seq('enum', '{', repeat($.enum_param_list), '}'),
    error_literal: $ => seq('error', '{', repeat($.error_param_list), '}'),
    struct_initializer: $ => seq(choice($.member_chain, $.identifier, '.'), '{', optional($.struct_field_initializers), '}'),
    struct_field_initializers: $ => seq($.identifier, ':', $.expr),
    enum_error_initializer: $ => seq('.', $.identifier, optional(seq('(', $.expr, ')'))),
    array_initializer: $ => seq('.', '[', optional($.expr_list), ']'),
    expr_list: $ => seq($.expr, repeat(seq(',', $.expr))),
    identifier: $ => token(/(?:[A-Za-z][A-Za-z0-9_]*|_[A-Za-z0-9_]*[A-Za-z][A-Za-z0-9_]*)/),
    digit: $ => /[0-9]/,
    type_expr: $ => choice($.array_type, $.pointer_type, $.optional_type, $.identifier, $.member_chain),
    array_type: $ => seq('[', ']', $.type_expr),
    pointer_type: $ => seq('*', $.type_expr),
    optional_type: $ => seq('?', $.type_expr),
  }
});
