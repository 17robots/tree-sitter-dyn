module main;

io := use std:io;
heap := use std.io;

BasicEnum := enum {
	item,
	other,
	float,
	something,
	chained,
};

PartneredEnum := enum {
	something2 := 1; // can have decls in these, they just end in a semicolon instead of a colon
	item: i32,
	other: i12,
	float: f32,
	something: struct {},
	chained: enum {},
	err: error {},
};

BasicError := error {
	something := 1; // can have decls in these
	cool,
	message
};

PartneredError := error {
	something := 1; // can have decls in these
	cool: PartneredEnum,
	message: []u8,
};

AStruct := struct {
	items: i32,
	here: i32,
	other: []i32,
	new := () AStruct => .{ items: 0, here: 0, other: .[] }; 
};

main := () ! {
	// variables, immutable by default
	x := 2;
	y: i32 = 2;
	mut z := 2;
	single: f32 = 1.0;
	double: f64 = 1.0;
	char := 'a'; // u8
	boolean := falase; // u1
	// cannot do boolean = true because not mutable

	// optionals, need type specified
	optional_val: ?i32 = 100;
	mut optional_val2: ?i32 = null;

	io.println("Optional val: {}", if optional_val: |v| v else "null"); // shows off if statement as expr in one use case using capture for optional type
	io.println("Optional_val: {}", optional_val.?); // optional dereference
	a := optional_val2 ?? 4; // nullish coalescing
	optional_val2 = 4; // actually assign it
	b := optional_val2 ?? 0;

	// pointers
	immut_val: i32 = 1;
	mut mut_val: i32 = 1;
	immut_val_ptr := &immut_val; // val and ptr cannot be changed
	mut_val_ptr: *i32 = &mut_val; // val can be changed since val is mut ptr cannot
	mut mut_mut_val_ptr: *i32 = &mut_val; // ptr can be changed and val can be changed
	io.print("immut_val == dereferenced immut_val_ptr? {}", immut_val == immut_val_ptr.*); // ptr derefernce

	mut_val_ptr.* += 1; // ptr dereference as assign
	mut_mut_val_ptr = undefined; // unassign the ptr

	// arrays
	mut nums := .[1,2,3,4,5];
	nums2: []i32 := .[];
	nums[0] *= 2;
	nums[1] = 4;
	nums[2] += nums[2];

	// ifs, can be used as expressions or statements
	yes := true;
	if yes {
		io.print("Hello World\n");
	} else {
		io.println("Uh oh\n");
	}
	// shorthand since only one statement
	if yes io.print("Hello World\n") else {
		io.print("Uh oh\n");
	}
	// even shorterhand since both only one statement
	if yes io.print("Hello World\n") else io.println("Uh oh\n");

	// other way to think of it
	io.print("{}\n", if yes "Hello World" else "Uh oh");

	some_other_optional_val: ?i32 = null;

	if some_other_optional_val: |capture| io.print("We have a val {}", capture); // this could also be surrounded in {} and work fine

	// fors
	for 0..10: |i| { io.print("{}", i); } // again no {} needed if single statement
	for 0..10, 0..10: |i, j| io.println("These increment at the same time {} {}", i, j); // tandem conditions
	for 0..10: |i| for 0..10 |j| io.print("These increment differently {} {}", i, j);
	some_other_array := [1,2,3];
	for some_other_array: |i| io.print("Arr val: {}", i); // can do on arrays
	for some_other_array, 0..some_other_array.len: |i, j| io.print("Arr ind: {}, arr val: {}", j, i);
	
	// whiles
	mut while_val: i32 = 0;
	while while_val < 10 i += 1;
	while_val = 0;
	while while_val < 10 {
		io.print("While val: {}", while_val);
		while_val += 1;
	}
	mut another_while_val: ?i32 = while_val;
	while another_while_val: |mut i| { // goes until optional val is null
		io.print("While val: {}", i);
		if i < 10 another_while_val = null;
	}

	// defer, can also have a capture for errors, but those are covered later
	defer io.print("This prints last");
	defer if yes io.print("This prints third");
	defer {
		io.print("This prints first");
		io.print("This prints second");
	}

	// functions, can also return struct literals, enum literals, error literals, etc
	internal_fn := () { io.print("Im an internal fn"); }; // no type after () means void
	internal_fn();
	some_number := () i32 { return 100; };
	some_number2 := () i32 => 100; // arrow for shorthand with one valid stmt or expr
	some_math := (x: i32, y: i32) i32 => x + y;
	some_math2 := (x, y: i32) i32 { return x + y; };
	mut res = 0;
	manipulate_args := (x, y: i32, res: *i32) => res.* = x + y; // fn args immutable, need pointer type to manipulate
	manipulate_args(1,2,&res); // call with it
	MathFn: type = (i32,i32)i32;
	do_math : fn = (math: MathFn, x, y: i32) => math(x, y);
	do_math((x,y: i32) => x + (2 * y), 1,2);

	// struct, enum, error instantiating, see above for some examples of each
	basic_enum := .item;
	partnered_enum := .item(2);
	basic_error := .cool;
	partnered_error := .cool(.other(1));
	a_struct := AStruct{ items: 12, here: 12, other: .[] };
	a_struct2 : AStruct = .{ items: 12, here: 12, other .[] };
	a_struct3 : AStruct.new(); // using a method on a struct
	io.print("{} {} {}", a_struct.items, a_struct2.here, a_struct3.other);
	// since these are all expressions, they can be passed into fns and also declared in scopes too, and also returned from fns
	a_function_with_stuff := (s: struct {}, en: enum {}, er: error {}) type => struct {};

	// match stuff
	a_cool_cool_num := 3;
	match a cool_cool_num {
		0: io.print("A 0"),
		1..12: io.print("In this range"),
		13..17, 20..30: io.print("Weird range for this but it works"), // lets you separate matches by ,
		_: io.print("The default case"),
	}

	a_cool_match_thing := match a_cool_num { // matches can be used as exprs too
		1..12: a_cool_number,
		_: block: {
			break :blk 13;
		},
	};

	match basic_enum { // enums have to be exhaustive or have a _ arm
		.item: io.print("item"),
		.other: io.print("other"),
		.float: io.print("float"),
		.something: io.print("something"),
		.chained: io.print("chained"),
	}

	match partnered_enum {
		.item: |c| io.print("c: {}", c), // arms can capture if they are partnered
		.other: |c| io.print("c: {}", c),
		.float: |c| io.print("c: {}", c),
		.something: |c| io.print("c: {}", c),
		.chained: |c| io.print("c: {}", c),
		_: io.print("We dont care about the rest"),
	}

	// metaprogramming
	List := (T: comp type) type => struct {}; // comp is keyword for comptime, meaning the type needs to be known at compile time
	print_things_at_comptime := () => io.print("We are a thing");
	comp print_thing_at_comptime(); // run this at comptime
	return_pi := () f32 => 3.14;
	pi := comp return_pi(); // use comp to calculate val at comptime if possible
	inline for 0..12: |i| io.print("Woah\n"); // unroll for loop as statements if val known at comp time
	inline_fn := inline () => io.print("This fn gets written out in place of each call"); // inline keyword also used for fn literals
	inline_fn(); // see here

	label: { // all blocks can be given a label but it's optional
		// blocks can also be run in other scopes as well
	}

	// error handling
	DivideError := error {
		DivideByZero
	};
	divide(x,y) f32!DivideError => if y == 0 DivideError.DivideByZero else x / y;

	// two ways to do this
	try divide(1,1); // try is shorthand for fn() catch |e| return e; this is also not allowed unless the fn is marked as errorable
	v := divide(1,0) catch |e| blk: {
		io.print("We got an error {}", e);
		break :blk 1;
	};
	// can also defer on error with the error capture
	other_error_fn := () ! { // no item before ! means void fn and nothing after ! means figure out the error union
		// can use try here because function expects it can error
		// can also use error defers here too
		defer |e| {} // cleanup on error for example (can also be a single statement instead)
	}
};

// fns can also be declared out here
