(* ========================================================= *)
(*                   High-Level Structure                  *)
(* ========================================================= *)

Program         ::= ModuleDecl { PubDecl | Decl }

ModuleDecl      ::= "module" String ";"
PubDecl         ::= "pub" Decl

(* ========================================================= *)
(*                    Declarations                         *)
(* ========================================================= *)

Decl            ::= UseDecl
                  | FnDecl
                  | VariableDecl
                  | EnumDecl
                  | ErrorDecl
                  | StructDecl

UseDecl         ::= "use" [ Identifier ] String ";"

FnDecl          ::= Identifier "=" "(" [ ParamList ] ")" ( Block | ArrowExpression )

ParamList       ::= Param { "," Param }
Param           ::= [ "mut" ] Identifier { "," Identifier } ":" TypeExpr [ "=" Expr ]

VariableDecl    ::= Identifier { "," Identifier } 
                    ( ":" TypeExpr "=" Expr | ":=" Expr ) ";"
                    
MutableVariableDecl 
                ::= "mut" Identifier { "," Identifier }
                    [ ":" TypeExpr "=" Expr | ":=" Expr ] ";"

EnumDecl        ::= Identifier "=" EnumLiteral
EnumParamList   ::= { EnumMember }
EnumMember      ::= EnumParam | FnDecl | VariableDecl | EnumDecl | ErrorDecl | StructDecl
EnumParam       ::= Identifier [ ":" TypeExpr ] ","

ErrorDecl       ::= Identifier "=" ErrorLiteral
ErrorParamList  ::= { ErrorMember }
ErrorMember     ::= ErrorParam | FnDecl | VariableDecl | EnumDecl | ErrorDecl | StructDecl
ErrorParam      ::= Identifier [ ":" TypeExpr ] ","

StructDecl      ::= Identifier "=" StructLiteral
StructParamList ::= { StructMember }
StructMember    ::= StructParam | FnDecl | VariableDecl | EnumDecl | ErrorDecl | StructDecl
StructParam     ::= Identifier { "," Identifier } ":" TypeExpr ","

(* ========================================================= *)
(*                   Statements & Blocks                   *)
(* ========================================================= *)

Block           ::= "{" { Stmt } "}"
Label           ::= Identifier ":" Block

Stmt            ::= MutableVariableDecl
                  | IfStmt
                  | MatchStmt
                  | ReturnStmt
                  | BreakStmt
                  | ForStmt
                  | WhileStmt
                  | AssignmentStmt
                  | Decl
                  | Call
                  | DeferStmt

Call            ::= ( MemberChain | LambdaExpr ) FnCallSuffix ";"

IfStmt          ::= "if" Expr [ ":" Capture ] ( Block | Stmt )
                  [ "else" ( IfStmt | Block | Stmt ) ]

IfExpr          ::= "if" Expr [ ":" Capture ] ( Block | Expr )
                  [ "else" ( IfExpr | Block | Expr ) ]

MatchStmt       ::= "match" Expr "{" [ MatchArms ] "}"
MatchArms       ::= MatchArm { "," MatchArm }
MatchArm        ::= MatchPattern ":" [ Capture ] ( Block | Stmt )

MatchExpr       ::= "match" Expr "{" [ MatchArmsExpr ] "}"
MatchArmsExpr   ::= MatchArmExpr { "," MatchArmExpr }
MatchArmExpr    ::= MatchPattern ":" [ Capture ] ( Label | Expr )
MatchPattern    ::= "_" | Expr | RangeExpr

DeferStmt       ::= "defer" [ Capture ] ( Stmt | Block )

ReturnStmt      ::= "return" [ Expr ] ";"

BreakStmt       ::= "break" [ LabelBreak ] ";"
LabelBreak      ::= ":" Identifier [ Expr ]

ForStmt         ::= "for" Expr ":" Capture ( Label | Stmt )
WhileStmt       ::= "while" Expr [ ":" Capture ] ( Label | Stmt )

AssignmentStmt  ::= MemberChain AssignmentOp Expr ";"
Lhs             ::= MemberChainLhs
AssignmentOp    ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^="

(* ========================================================= *)
(*                    Expressions                          *)
(* ========================================================= *)

Expr            ::= Literal
                  | BinaryExpr
                  | UnaryExpr
                  | LambdaExpr
                  | Identifier
                  | GroupedExpr
                  | MemberChain
                  | LambdaExpr FnCallSuffix
                  | StructLiteral
                  | EnumLiteral
                  | ErrorLiteral

BinaryExpr      ::= Expr Op Expr
Op              ::= "+" | "-" | "*" | "/" | "%" 
                  | "|" | "&" | "^" | ">>" | "<<" 
                  | "==" | "!=" | "||" | "&&"

UnaryExpr       ::= PrefixExpr | PostfixExpr
PrefixExpr      ::= ( "-" | "&" | "!" | "~" ) Expr
PostfixExpr     ::= Expr ( "++" | "--" )

MemberChain     ::= Identifier { Suffix }
Suffix          ::= SuffixNoCall | FnCallSuffix
SuffixNoCall    ::= MemberAccessSuffix 
                  | PointerDereferenceSuffix 
                  | OptionalDereferenceSuffix 
                  | ArrayIndexSuffix

MemberChainLhs  ::= Identifier { SuffixNoCall | ( FnCallSuffix SuffixNoCall ) }

MemberAccessSuffix
                ::= "." Identifier
PointerDereferenceSuffix
                ::= ".*"
OptionalDereferenceSuffix
                ::= ".?"
ArrayIndexSuffix::= "[" Expr "]"

FnCallSuffix    ::= "(" [ ArgumentList ] ")"
ArgumentList    ::= Expr { "," Expr }

LambdaExpr      ::= "(" [ ParamList ] ")" ( Block | ArrowExpression )
GroupedExpr     ::= "(" Expr ")"

(* ========================================================= *)
(*                    Literals                           *)
(* ========================================================= *)

Literal         ::= Number | String | Char | Boolean | "undefined" | "null"

Number          ::= Int | Float
Int             ::= Digit { Digit }
Float           ::= Int "." Digit { Digit }

String          ::= "\"" { StringCharacter } "\""
StringCharacter ::= EscapeSequence | NonEscapeCharacter
EscapeSequence  ::= "\\" ( "\"" | "\\" | "n" | "t" | "r" )
NonEscapeCharacter
                ::= ? any character except "\"" and "\\" ?

Char            ::= "'" ( EscapeSequence | NonEscapeChar ) "'"
NonEscapeChar   ::= ? any character except "'" and "\\" ?

Boolean         ::= "true" | "false"

StructLiteral   ::= "struct" "{" [ StructParamList ] "}"
EnumLiteral     ::= "enum" "{" [ EnumParamList ] "}"
ErrorLiteral    ::= "error" "{" [ ErrorParamList ] "}"

(* ========================================================= *)
(*                    Lexical Tokens                       *)
(* ========================================================= *)

Identifier      ::= ( Letter | "_" ) { Letter | Digit | "_" }
Letter          ::= "a".."z" | "A".."Z"
Digit           ::= "0".."9"

